---> Файлы
В JS каждый файл это как бы отдельная программа, т.к. ошибка в одном файле во время прасинга/компиляции или исполнении не обязательно приводит к остановке исполнения другого файла.
Единственное исключение - когда файлы шарят общее сотсояние и глобал скоуп.

--> Values, значения.
Примитивы и объекты.
`` - interpolation
Прим: string, number, boolean, null, undefined, symbol, bigInt??.
undefined - предпочтительнее, чем null усли нужно пустоезначение.

Всё кроме примитивов - объекты. 
Ф-ции - особый подтип объекта. typeOf вернет "function"
coercion - приведение типов.

--> Variables.
Использовать const по возможности только с примитвами, чтобы у читающего код не было ощущения, что это значение нельзя мутировать (в случае с массивами и объектами это конечно же не так)
Прикол, помимо очевидных способов объявления переменных (const, let, var), есть еще несколько:
- function declaration
- function parameter
- catch (err)

--> Functions.
Ф-ции в понимании JS это скорее процедуры нежели в-ции из ФП
function decalaration - название ф-ции связывается со значением в момент компиляции
function expression -  название связывается в рантайме, hoisting.
У ф-ции параметры, у вызова ф-ции аргументы.

--> Comparisons, сравнение.
=== - strict, строгое сравнение. Часто описывается, как проверка значения и типа, но фишка в том, что все сравнения в JS проверяют тип, но только строгое сравнение запрещает приведение/conversion(coercion).
Но есть нюанс (два кейса, когда это сравнение врет):
NaN === NaN;            // false
0 === -0;               // true
Для NaN сравнений лучше: Number.isNaN(..), Object.is(..)
Для -0 лучше: Object.is(..)
Шутка: "quadruple-equals" ==== (Object.is(..)) строгое-строгое сравнение
Ну и само собой: === не делает структурное сравнение (structural equality), бесполезен для сравнения объектов. Вместо этого, на объектах он делает "identity equality"/"reference identity"

--> Coercive Comparisons, сравнения с приведением.
== - многие считают, что он не учитывает тип, но это не так. Просто он разрешает приведение перед сравнением, если типы разные.
Приколы:
"" == 0 //true
0 == false //true
Потому что == предпочитает сравнивать всё в примитивных числовых значениях.
<, >, <=, >= -- тоже делают приведение перед сравнением, если типы отличаются.
Если сравниваются две строки, то они сравниваются как строки, алфавитно.
"10" < "9" //true
!Стараться не использовать несовпадающие типы при сравнении.

--> Организация кода. 
- Классы.
Классы: данные и поведение.
Методы(поведение) могут быть вызваны только на экземплярах класса.
- Наследование.
class Cat extends Animals
конструктор родителя: super()
Факт сосуществования двух  методов с одинаковым названием (родительский и переопределенный) - есть полиморфизм.
- Модули.
$ Классика. В классическом понимании, это внешняя ф-ция, которая вызывается хотя бы раз и возвращает другие ф-ции и значения. Еще такие ф-ции называют "module factories".
Другие вариации factory function: AMD, UMD, CommonJS 
$ ES modules (ESM)(ES6).
Различия: 
Нет, ф-ции обертки, которая определяет модуль, теперь это файл. Один модуль, один файл. 
Нет явного взаимодействия с “API” модуля. Есть только export, остального не видно.
Не нужно создавать эксземпляры, просто делаем import. ESM по-сути синглтоны, импортированы единожды, существуют в ед. экземпляре, остальные импорты хранят ссылку на него. Если нужно несколько инстансов, то идем по классике или комбинируем или юзаем классы.