--> Итераторы
next()/done (true/false)

Потребители итераторов (iterator-consumption protocol):
for...of loop
... operator (spread)

Протокол создает инстанс итератора из iterable и потребляет его, до его выполнения.
У объектов могут быть разные виды итераторов, например у Map это могут быть entries, values, keys


--> Closure, Замыкание
Ф-ция запоминает и продолжает иметь доступ к переменным снаружи своего скоупа, даже когда исполняется в другом месте. 


--> This
Популярные недопонимания:
- this функции указывает на нее саму.
- this указывает на инстанс, которосу принадлежит метод.

Помимо scope привязанного к ф-ции ч-з closure, у ф-ции есть другое св-во: execution context и доступ к нему для ф-ции открыт ч-з this.
Scope - статический, фиксированный набор переменных доступных в тот момент и время, где определили ф-цию. Всегда тот же, для данной ф-ции.
Execution context - динамический, зависим полностью от того, КАК вызвана ф-ция вне зависимости от того, где определена она и вызвана. Доступен на время исполнения.
this - динамическая характеристика, определяется каждый раз при вызове.
В нестрогом режиме режиме, у ф-ций с this execution context будет глобальный объект window.
call(this_ex_context) - для вызова с контекстом 

--> Prototypes
Это св-во объекта, связано с уже существующим объектом, "prototype chain".
Цель: доступ к св-вам/методам, которых нет у объекта Б делегируются (delegated) объекту А. Это работает только на чтение, не на запись, попытка изменить св-во создаст такое же свойство в дочернем объекте, оно будет затенять "shadowing" одноименное св-во прототипа.
Например [[Prototype]]: Object, содержит toString, valueOf
Object.create(..) - для создания объекта на базе другого объекта (прототип укажет на него) (prototype link).
Object.create(null) - создаст объект не связанный прототипом ни с чем.
Основной смысл динамического контекста "this" это то, что мы можем получать его ч-з цепочку прототипов.

